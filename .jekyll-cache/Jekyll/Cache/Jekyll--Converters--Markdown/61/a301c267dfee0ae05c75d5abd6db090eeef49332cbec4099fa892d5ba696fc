I"⁄m<p>Over many years, I‚Äôve come together with a particular group of friends to play <em>Axis &amp; Allies (A&amp;A)</em>, a World War II inspired board game.</p>

<p>For those unfamiliar, <em>A&amp;A</em> puts players in charge of the major nation states of the WWII era. During each turn of the game, you receive IPCs (the game‚Äôs currency), purchase military units, declare and resolve combat, and make additional non-combat moves. It‚Äôs a game of grand-scale strategy, but combat between armies is at the heart of the game. As a player, combat is how you capture new territories, grow your economy, and ultimately win the game.</p>

<p>The combat in <em>A&amp;A</em> is really (mathematically) interesting! Like many other board games, dice rolls determine the outcomes, but unlike those other dice-based board games (<em>Risk</em>, for example), the probability of success varies based on the types of units engaged and how hits are distributed round-to-round. The more units involved, the less straightforward it is to estimate the probability of success. It can be very difficult, if not impossible, to estimate your chances of winning without the help of a computer - as we shall see.</p>

<h2 id="what-youll-need">What You‚Äôll Need</h2>

<p>This article is aimed at beginner and intermediate JavaScript developers interested in exploring code-level concerns while implementing a multi-step simulation algorithm. Some more advanced developers and <em>Axis &amp; Allies</em> enthusiasts may also be interested.</p>

<ol>
  <li>The main thing you‚Äôll need is a way to run JavaScript code. You could create an empty HTML page with a <code class="language-plaintext highlighter-rouge">&lt;script&gt;</code> tag and open that in a browser, but I also highly recommend <a href="https://codepen.io">CodePen</a> for prototyping small projects like this.</li>
  <li>At the end of the article, we‚Äôll use <a href="https://vuejs.org">VueJS</a> to build a user interface that receives user input and displays results. See <a href="https://vuejs.org/v2/guide/#Getting-Started">VueJS - Getting Started</a>.</li>
</ol>

<h2 id="what-is-my-chance-of-winning">What is My Chance of Winning?</h2>

<p>Players entering combat in <em>A&amp;A</em> are mainly wondering, ‚ÄúWhat is my chance of winning this?‚Äù Let‚Äôs look at a small combat to see how we might answer that question.</p>

<p>In <em>A&amp;A</em>, Infantry have a weak attack stat of 1 and a slightly better defense stat of 2. When resolving combat, each player rolls a six-sided die. An attack stat of 1 means the attacker must roll a 1 to hit the defender, while the defender must roll a 1 or 2 to hit the attacker.</p>

<p>So in a combat between two Infantry (one attacking, on defending), the defender seems favored to win, because they are more likely to roll a ‚Äúhit.‚Äù But by how much are they favored? Combat proceeds in rounds until the attacker gives up (retreats) or until one side has lost all of its units. In this case, each round of combat may have one of four outcomes:</p>

<ol>
  <li>Attacker hits, defender misses (combat ends)</li>
  <li>Attacker misses, defender hits (combat ends)</li>
  <li>Attacker hits, defender hits (combat ends)</li>
  <li>Attacker misses, defender misses (combat continues)</li>
</ol>

<p>Look at #4 again, and notice that there is a scenario where both players miss and combat continues. In fact, this could happen every round, forever. What this means is that even this basic combat situation has an <em>infinite probability space</em>! There‚Äôs an (extremely low) chance that this combat could continue unresolved for eternity. In practice, though, it‚Äôs not unusual to wait 2-3 rounds for someone to hit.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>By the way, the probability that the attacker will win is about 25%. This <em>just so happens</em> to be approximately the average between the attacker‚Äôs chance to hit (one in six or 16.66%) and the defender‚Äôs (two in six or 33.33%). But unfortunately that is not a general rule we can apply to all combats. For instance, in a combat between one Tank (attacks at 3) and one Infantry (defends at 2), the Tank is slightly favored at about 50.4%. If you take a moment to think about the probabilities of rolling certain numbers, these results may seem very unintuitive, and I think they are.</p>

<p>But that is jumping ahead!</p>

<p>What it comes down to is that every combat can be visualized as a tree diagram.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            Start
               /         /         \     \
Round 1   attacker    defender    draw   continue
            wins        wins                  \
Round 2+                                  same tree, repeated...
</code></pre></div></div>

<p>And again, this is one of the most simple examples. As you add units to each side, the tree of possible and likely outcomes grows exponentially.</p>

<h2 id="brute-force-vs-simulation">‚ÄúBrute Force‚Äù vs. Simulation</h2>

<p>In more complex combats with many units we would see a tree with many more branches representing every possible combination of hits and misses, and from this we could observe that the overall probability of success shifts every round, depending on the luck of the players in the previous round(s). For instance, if one player scores many hits during the first round and the other player is unlucky and does not, then that first player has significantly bettered their odds for all future rounds. Put another way, they‚Äôve narrowed the probability space in their favor.</p>

<p>To compute the probability of success by hand, we‚Äôd have to look at every possible scenario and its likelihood. With only a handful of units we‚Äôd be looking at hundreds, even thousands of possible outcomes, each with their own distinct probability. This ‚Äúbrute force‚Äù strategy would work, but it could be endless, even for a computer.</p>

<p>But there is a better way: the <strong>Monte Carlo simulation</strong>. In this article, we will write a Monte Carlo simulation in JavaScript that repeatedly runs <em>Axis &amp; Allies</em> combats and records the number of scenarios. When we run it 1,000 or 5,000 times, we will start to converge on the overall probability of success or failure. While this might not be as precise a probability as the ‚Äúbrute force‚Äù approach, it should be enough to tell us whether or not it‚Äôs a good idea to invade that province we‚Äôre looking at.</p>

<h2 id="modeling-axis--allies-units">Modeling Axis &amp; Allies Units</h2>

<p>With that background set, let‚Äôs start to look at some data and code. As we go, consider the following:</p>

<ol>
  <li>How can we best structure our data to produce sensible, easy-to-read code?</li>
  <li>Since we are building a simulation that needs to run thousands of times, how will our data decisions impact performance - that is, the <em>speed</em> of the simulation?</li>
</ol>

<p>Let‚Äôs look at how we might structure data for our simulation. Each unit in <em>A&amp;A</em> has a few elements: a name, IPC value, attack stat, and defense stat. In JavaScript, we might represent that with object literals like so:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Infantry</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Infantry</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">ipc</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="na">attack</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">defense</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">Tank</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Tank</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">ipc</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
  <span class="na">attack</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="na">defense</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p>I think that makes a lot of sense and is easy to read. So now we have objects to represent units. <em>Axis &amp; Allies</em> has many more units than this and some special rules, but we‚Äôll focus on these to keep our code samples small.</p>

<p>Now let‚Äôs create some data structures to represent the <em>lists</em> of units being used by each of our players in a combat. Let‚Äôs say the attacker is invading with one Infantry and one Tank against a defender‚Äôs single Infantry:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">attackerUnits</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Infantry</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">ipc</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="na">attack</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">defense</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Tank</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">ipc</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
    <span class="na">attack</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="na">defense</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">];</span>
<span class="kd">const</span> <span class="nx">defenderUnits</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Infantry</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">ipc</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
    <span class="na">attack</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="na">defense</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">];</span>
</code></pre></div></div>

<p>Here we arrive at our first interesting data modeling decision. Do you know the difference between the above code and this?</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Infantry</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Infantry</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">ipc</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="na">attack</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
  <span class="na">defense</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">Tank</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Tank</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">ipc</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
  <span class="na">attack</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="na">defense</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>
<span class="kd">const</span> <span class="nx">attackerUnits</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Infantry</span><span class="p">,</span> <span class="nx">Tank</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">defenderUnits</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Infantry</span><span class="p">];</span>
</code></pre></div></div>

<p>Besides being a bit shorter, this code snippet has another very important attribute: both the <code class="language-plaintext highlighter-rouge">attackerUnits</code> and <code class="language-plaintext highlighter-rouge">defenderUnits</code> lists contain a <strong>reference</strong> to the same <code class="language-plaintext highlighter-rouge">Infantry</code> object, while in the first example, the lists referenced entirely different objects. This is because the object literal syntax (the curly braces <code class="language-plaintext highlighter-rouge">{}</code>) creates a new object in memory whenever it is used.</p>

<p>When it comes to looking at the performance of our simulation, this fact will be very important. Making many reads and writes to memory could slow things down, and objects in particular in JavaScript have extra memory overhead, including ‚Äúhidden classes‚Äù that are created for each object by the browser‚Äôs JavaScript engine. <a href="https://blog.usejournal.com/the-secrets-of-javascript-object-performance-optimization-5b648fc99f59">This article</a> explores this in more detail.</p>

<p>Now suppose we decide to refactor a bit and create a formal class to represent units:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Unit</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">ipc</span><span class="p">,</span> <span class="nx">attack</span><span class="p">,</span> <span class="nx">defense</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">ipc</span> <span class="o">=</span> <span class="nx">ipc</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">attack</span> <span class="o">=</span> <span class="nx">attack</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">defense</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Given that class, we could do either of the following:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// (1) Separate object instances in memory</span>
<span class="kd">const</span> <span class="nx">attackerUnits</span> <span class="o">=</span> <span class="p">[</span>
  <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="dl">"</span><span class="s2">Infantry</span><span class="dl">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
  <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="dl">"</span><span class="s2">Tank</span><span class="dl">"</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="p">];</span>
<span class="kd">const</span> <span class="nx">defenderUnits</span> <span class="o">=</span> <span class="p">[</span><span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="dl">"</span><span class="s2">Infantry</span><span class="dl">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)];</span>

<span class="c1">// (2) References to the same instances in memory,</span>
<span class="kd">const</span> <span class="nx">Infantry</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="dl">"</span><span class="s2">Infantry</span><span class="dl">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">Tank</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="dl">"</span><span class="s2">Tank</span><span class="dl">"</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">attackerUnits</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Infantry</span><span class="p">,</span> <span class="nx">Tank</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">defenderUnits</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Infantry</span><span class="p">];</span>
</code></pre></div></div>

<p>This is essentially the same comparison we made before, except that this time we are using the <code class="language-plaintext highlighter-rouge">new</code> keyword with a class. And once again, the second example will take up less memory than the first. With only three units in play, there isn‚Äôt much of a difference, but in a scenario where both sides have, say, ten units, there would be more than a tenfold difference in memory use between these two approaches.</p>

<h2 id="outlining-the-problem">Outlining the Problem</h2>

<p>Before writing code, it‚Äôs always helpful to break down the problem at hand by writing some ‚Äúpseudo-code‚Äù to describe the steps we need to take. We know that a combat goes in ‚Äúrounds,‚Äù so let‚Äôs start there and write out the steps in each round:</p>

<p><strong>Steps in a Round</strong></p>

<ol>
  <li>Attacker rolls one die for each attacking unit</li>
  <li>Attacker compares each die roll to the unit‚Äôs attack stat</li>
  <li>Attacker records a hit for each die roll equal to or less than the unit‚Äôs attack stat</li>
  <li>Defender rolls one die for each defending unit</li>
  <li>Defender compares each die roll to the unit‚Äôs defense stat</li>
  <li>Defender records a hit for each die roll equal to or less than the unit‚Äôs defense stat</li>
  <li>Attacker and defender remove units that were ‚Äúhit‚Äù</li>
</ol>

<p>Phew, that‚Äôs actually a lot of steps! But it‚Äôs not too bad. You can probably already imagine that that Step 1 will be a call to a random number generator, Step 2 will be some kind of <code class="language-plaintext highlighter-rouge">if</code> statement, and Step 3 will increment some kind of counter. And then you‚Äôve also probably noticed that Steps 4-6 are pretty much the same as Steps 1-3, just taken from the defender‚Äôs perspective.</p>

<p>Now let‚Äôs ‚Äúgo up a level‚Äù and see how we can use the above routine to simulate an entire combat:</p>

<p><strong>Steps in a Combat</strong></p>

<ol>
  <li>Set up the attacker and defender unit lists</li>
  <li>Do a round</li>
  <li>Check for win, loss, or draw</li>
  <li>End on a win, loss, or draw, otherwise repeat from Step 2</li>
</ol>

<p>Alright, this is a bit more straightforward. We‚Äôve already decided how we‚Äôll do Step 1, and we‚Äôve also covered Step 2. Step 3 looks like it will be some <code class="language-plaintext highlighter-rouge">if</code> statements, and Step 4 says ‚Äúrepeat from Step 2‚Äù, so it looks like we‚Äôll be wrapping Steps 2-4 in some kind of loop.</p>

<p>Finally, there‚Äôs one more level to consider. Remember, we don‚Äôt just want to run the combat once. We want to run it thousands of times and keep track of wins and losses. So we also need to outline the steps for the Monte Carlo Simulation.</p>

<p><strong>Steps in a Monte Carlo Simulation of Many Combats</strong></p>

<ol>
  <li>Set up the attacker units, defender units, and <code class="language-plaintext highlighter-rouge">x</code> number of simulations to run</li>
  <li>Run a combat</li>
  <li>Record the combat result (win, loss, or draw)</li>
  <li>Repeat from Step 2 until we have run <code class="language-plaintext highlighter-rouge">x</code> number of times</li>
  <li>Display results</li>
</ol>

<p>This also makes a lot of sense. The main things to consider here are: looping <code class="language-plaintext highlighter-rouge">x</code> times, resetting the ‚Äúgame board‚Äù before each combat (Step 2), counting wins, losses, and draws, and finally displaying results.</p>

<p>And that appears to be everything we‚Äôll need. So let‚Äôs now take these checklists and use them to guide our coding. We can put the above checklists together into a pseudo-code specification that defines our whole application.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// STEPS IN A MONTE CARLO SIMULATION</span>
<span class="c1">// 1. Set up the attacker units, defender units, and `x` number of simulations to run</span>
<span class="c1">// 2. Run a combat</span>
<span class="c1">// STEPS IN A COMBAT</span>
<span class="c1">// 1. Set up the attacker and defender unit lists</span>
<span class="c1">// 2. Do a round</span>
<span class="c1">// STEPS IN A ROUND</span>
<span class="c1">// 1. Attacker rolls one die for each attacking unit</span>
<span class="c1">// 2. Attacker compares each die roll to the unit's attack stat</span>
<span class="c1">// 3. Attacker records a hit for each die roll equal to or less than the unit's attack stat</span>
<span class="c1">// 4. Defender rolls one die for each defending unit</span>
<span class="c1">// 5. Defender compares each die roll to the unit's defense stat</span>
<span class="c1">// 6. Defender records a hit for each die roll equal to or less than the unit's defense stat</span>
<span class="c1">// 7. Attacker and defender remove units that were "hit"</span>
<span class="c1">// 3. Check for win, loss, or draw</span>
<span class="c1">// 4. End on a win, loss, or draw, otherwise repeat from Step 2</span>
<span class="c1">// 3. Record the combat result (win, loss, or draw)</span>
<span class="c1">// 4. Repeat from Step 2 until we have run `x` number of times</span>
<span class="c1">// 5. Display results</span>
</code></pre></div></div>

<p>Each level of indentation represents a different checklist, and perhaps you can already see that this is a pretty accurate outline of how the final code might look with the nested loops we will have to create. Laying out the steps in comments in this way can help you stay oriented while working through complicated, multi-step problems like this.</p>

<h2 id="coding-up-a-round">Coding up a Round</h2>

<p>Let‚Äôs zoom in on the inner-most code for playing a round of combat. Up to now we‚Äôve explored a couple ways of setting up our virtual game board for combat. Going forward, let‚Äôs stick with the <code class="language-plaintext highlighter-rouge">Unit</code> class above and these two unit instances:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Infantry</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="dl">"</span><span class="s2">Infantry</span><span class="dl">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">Tank</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="dl">"</span><span class="s2">Tank</span><span class="dl">"</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div></div>

<p>Let‚Äôs also set up the combat again, by giving each our players a list of units:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">attackerUnits</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Infantry</span><span class="p">,</span> <span class="nx">Tank</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">defenderUnits</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Infantry</span><span class="p">];</span>
</code></pre></div></div>

<p>Now, Step 1 calls for rolling a die, and rolling dice is pretty central to running a round, so let‚Äôs start by writing a function for that:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">randBetween</span><span class="p">(</span><span class="nx">min</span><span class="p">,</span> <span class="nx">max</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">max</span> <span class="o">-</span> <span class="nx">min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">min</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is a generic function to get an integer between <code class="language-plaintext highlighter-rouge">min</code> and <code class="language-plaintext highlighter-rouge">max</code>. <code class="language-plaintext highlighter-rouge">Math.random()</code> generates a decimal between 0 and 1, and the expression <code class="language-plaintext highlighter-rouge">* (max - min + 1) + min</code> re-scales that value to the range of min-max, finally <code class="language-plaintext highlighter-rouge">Math.floor()</code> rounds down to the nearest integer.</p>

<p>So to simulate a six-sided die roll, we would have to call <code class="language-plaintext highlighter-rouge">randBetween(1, 6)</code>. In our simulation, we only need six-sided die (aka ‚ÄúD6‚Äù), so we can make things more convenient for ourselves by defining a <code class="language-plaintext highlighter-rouge">rollD6</code> function.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// In traditional `function` syntax:</span>
<span class="kd">function</span> <span class="nx">rollD6</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">randBetween</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Or in new "fat arrow" syntax:</span>
<span class="kd">const</span> <span class="nx">rollD6</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">randBetween</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
</code></pre></div></div>

<p>Now that we can roll dice, let‚Äôs look at a couple ways we might do Steps 1-3. Since we need to roll for each attacking unit, perhaps a <code class="language-plaintext highlighter-rouge">for</code> loop comes to mind:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1. Attacker rolls one die for each attacking unit</span>
<span class="kd">let</span> <span class="nx">attackerHits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">attackerUnits</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">unit</span> <span class="o">=</span> <span class="nx">attackerUnits</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">roll</span> <span class="o">=</span> <span class="nx">rollD6</span><span class="p">();</span>

  <span class="c1">// 2. Attacker compares each die roll to the unit's attack stat</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">roll</span> <span class="o">&lt;=</span> <span class="nx">unit</span><span class="p">.</span><span class="nx">attack</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 3. Attacker records a hit for each die roll equal to or</span>
    <span class="c1">//    less than the unit's attack stat</span>
    <span class="nx">attackerHits</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This will definitely work, and it‚Äôs very readable. I think the steps here should be familiar to beginners who have learned the fundamental logic and control flow operators present in most modern languages. One JavaScript-specific quirk is the use of <code class="language-plaintext highlighter-rouge">const</code> and <code class="language-plaintext highlighter-rouge">let</code>. The <code class="language-plaintext highlighter-rouge">let</code> declaration allows us to change the value of a variable. So for example, we can increment <code class="language-plaintext highlighter-rouge">attackerHits</code> and <code class="language-plaintext highlighter-rouge">i</code> with the <code class="language-plaintext highlighter-rouge">++</code> operator. Meanwhile, we use <code class="language-plaintext highlighter-rouge">const</code> for values we don‚Äôt want to change. Variables in JavaScript are <em>block-scoped</em> (blocks in JS are usually areas enclosed by curly <code class="language-plaintext highlighter-rouge">{}</code> braces). That is why we can use <code class="language-plaintext highlighter-rouge">const unit</code> and <code class="language-plaintext highlighter-rouge">const roll</code> inside the <code class="language-plaintext highlighter-rouge">for</code> block. Every time the loop repeats, the previous variables are thrown out and new variables are instantiated inside that block scope.</p>

<p>In general, it‚Äôs recommended to use <code class="language-plaintext highlighter-rouge">const</code> whenever possible. Modifying values throughout complicated code risks confusion and difficult bugs.</p>

<p>As an aside, I find that many novice programmers are confused by the use of ‚Äòconst‚Äô with arrays and objects, because arrays and objects declared with ‚Äòconst‚Äô can still have their members modified, for example:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>

<span class="c1">// This is allowed, even though the above are 'const',</span>
<span class="c1">// because 'arr' or 'obj' are references to Array and Object</span>
<span class="c1">// instances. We are not changing those references here,</span>
<span class="c1">// we are just adding values inside of them.</span>
<span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// This is not allowed, because it is attempting to assign</span>
<span class="c1">// 'arr' and 'obj' to new Array and Object instances, and</span>
<span class="c1">// 'const' will not allow us to do that.</span>
<span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">];</span>
<span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="na">foo</span><span class="p">:</span> <span class="dl">"</span><span class="s2">bar</span><span class="dl">"</span> <span class="p">};</span>
</code></pre></div></div>

<p>Whether or not it is good idea to allow programmers to modify the contents of objects is a subject of great debate, especially in the functional JavaScript circles. For this reason, tools like <a href="https://immutable-js.github.io/immutable-js/">Immutable.js</a> were invented, which make it so that object properties can not be changed at all, only replaced with new object instances. I recommend giving this topic a Google.</p>

<p>So what other ways might we do this? Speaking of functional programming (FP), modern JS has some FP tools available to us like <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">filter</code>. We can use these to roll the dice:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">attackerHits</span> <span class="o">=</span> <span class="nx">attackerUnits</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">u</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">unit</span><span class="p">:</span> <span class="nx">u</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="nx">rollD6</span><span class="p">()</span> <span class="p">}))</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">roll</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">unit</span><span class="p">.</span><span class="nx">attack</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>
</code></pre></div></div>

<p>This does the same thing as above, but wow! It‚Äôs a lot shorter. In fact, it‚Äôs a one-liner. I‚Äôve just split the lines to make it easier to read. Let‚Äôs look at what is happening: first, the <code class="language-plaintext highlighter-rouge">map</code> function creates a new object from each unit in the <code class="language-plaintext highlighter-rouge">attackerList</code>. Each new object looks something like this: <code class="language-plaintext highlighter-rouge">{ unit, roll }</code>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">attackerList</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Infantry</span><span class="p">,</span> <span class="nx">Tank</span><span class="p">];</span>

<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">attackerList</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">u</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">unit</span><span class="p">:</span> <span class="nx">u</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="nx">rollD6</span><span class="p">()</span> <span class="p">}));</span>
<span class="c1">// [</span>
<span class="c1">//     { unit: Infantry, roll: 2 },</span>
<span class="c1">//     { unit: Tank, roll: 1},</span>
<span class="c1">// ]</span>
</code></pre></div></div>

<p>So we‚Äôve created a set of objects that pairs each unit with a die roll. There is a really cool and useful concept at work here called ‚Äúobject composition.‚Äù In a sense what we have done <em>extends</em> the capabilities of our <code class="language-plaintext highlighter-rouge">Unit</code> object without having to modify <code class="language-plaintext highlighter-rouge">Unit</code> itself. We‚Äôve done this by wrapping the unit in another object that adds a <code class="language-plaintext highlighter-rouge">roll</code> property.</p>

<p>Compare that to an approach like this, where we actually change the <code class="language-plaintext highlighter-rouge">Unit</code> class to add a <code class="language-plaintext highlighter-rouge">roll</code> property and <code class="language-plaintext highlighter-rouge">rollD6</code> method to the <code class="language-plaintext highlighter-rouge">Unit</code> class itself:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Unit</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ... see above</span>

    <span class="nx">rollD6</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">roll</span> <span class="o">=</span> <span class="nx">rollD6</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then we‚Äôd use that like this:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">attackerUnits</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">u</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">u</span><span class="p">.</span><span class="nx">rollD6</span><span class="p">());</span>
</code></pre></div></div>

<p>And that works just as well, we could loop over that list and compare <code class="language-plaintext highlighter-rouge">unit.roll &lt;= unit.attack</code>. The drawbacks of doing it this way are that we had to modify the <code class="language-plaintext highlighter-rouge">Unit</code> class to add this capability and our call to <code class="language-plaintext highlighter-rouge">unit.rollD6()</code> doesn‚Äôt reveal that <code class="language-plaintext highlighter-rouge">unit.roll</code> is being changed ‚Äúbehind the scenes.‚Äù</p>

<p>In larger projects, a change to a key data type like <code class="language-plaintext highlighter-rouge">Unit</code> might require changes elsewhere in the code. What‚Äôs more, in functional programming, functions that have ‚Äúside effects‚Äù like this are frowned upon, because they make it hard to see and reason about how and when data is changing. The side effect here is that <code class="language-plaintext highlighter-rouge">rollD6()</code> is changing the value of <code class="language-plaintext highlighter-rouge">unit.roll</code>. Compare this to our previous example where we generated <code class="language-plaintext highlighter-rouge">{unit, roll}</code> objects: <code class="language-plaintext highlighter-rouge">unit</code> was not modified in any way and it was clear to see how <code class="language-plaintext highlighter-rouge">roll</code> was being created and added to the data structure. Likewise, these rolls were created on time and never modified.</p>

<p>But perhaps the biggest issue with this approach goes back to our decision to re-use the same <code class="language-plaintext highlighter-rouge">Unit</code> instances. If we call <code class="language-plaintext highlighter-rouge">unit.rollD6()</code> on the <code class="language-plaintext highlighter-rouge">Infantry</code> instance, this will update <code class="language-plaintext highlighter-rouge">Infantry.roll</code> <em>everywhere</em> that <code class="language-plaintext highlighter-rouge">Infantry</code> is referenced. This isn‚Äôt really our intent, and it could lead to some unexpected behavior if we‚Äôre caught unaware.</p>

<p>Moving on, in the next line of our FP implementation, we have a <code class="language-plaintext highlighter-rouge">filter</code>. The filter uses the same comparison expression as the <code class="language-plaintext highlighter-rouge">if</code> statement in our <code class="language-plaintext highlighter-rouge">for</code>-loop example, only with slightly different syntax to access the properties of the objects we created: <code class="language-plaintext highlighter-rouge">r.roll &lt;= r.unit.attack</code>. Let‚Äôs break it down:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Take the result of the 'map' from above</span>
<span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span> <span class="na">unit</span><span class="p">:</span> <span class="nx">Infantry</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="mi">2</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">unit</span><span class="p">:</span> <span class="nx">Tank</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="mi">1</span> <span class="p">},</span>
<span class="p">];</span>

<span class="c1">// Filter by rolls less than or equal to the unit's attack stat</span>
<span class="kd">const</span> <span class="nx">hits</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">roll</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">unit</span><span class="p">.</span><span class="nx">attack</span><span class="p">);</span>
<span class="c1">// [{unit: Tank, roll: 1}]</span>

<span class="c1">// Get the count of the number of remaining elements.</span>
<span class="c1">// That is the number of hits!</span>
<span class="kd">const</span> <span class="nx">numHits</span> <span class="o">=</span> <span class="nx">hits</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="c1">// 1</span>
</code></pre></div></div>

<p>That‚Äôs pretty clever.</p>

<p>Now let‚Äôs review this approach by going back to our two questions before: (1) is this easier to read? I think that‚Äôs debatable. For a beginner, I would say probably not. The first example with the <code class="language-plaintext highlighter-rouge">for</code>-loop contains syntax that is more universally familiar. I think it‚Äôs also hard for newbies to imagine the intermediate data structures generated by <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">filter</code>, whereas in the <code class="language-plaintext highlighter-rouge">for</code>-loop example, it‚Äôs a bit easier to follow how individual values are changing. On the other hand, more advanced programmers who are able to read this code at a glance will probably appreciate this code for its clarity and ‚Äúelegance.‚Äù And I think they would feel reassured that this ‚Äúpure functional‚Äù syntax is doing exactly what it appears to be doing without side effects or surprises.</p>

<p>As for Question 2: what are the performance implications of this code? Compared to the <code class="language-plaintext highlighter-rouge">for</code>-loop version, the FP code is more inefficient for a few reasons. First, both <code class="language-plaintext highlighter-rouge">map</code> and <code class="language-plaintext highlighter-rouge">filter</code> are also loops. This means that the FP code loops two times through the <code class="language-plaintext highlighter-rouge">attackerList</code> instead of just once. Moreover, the <code class="language-plaintext highlighter-rouge">map</code> function generates objects, which as mentioned before have a bigger memory ‚Äúfootprint‚Äù than the primitive values being used in the <code class="language-plaintext highlighter-rouge">for</code>-loop example. And this is often how functional programming paradigm works ‚Äì it emphasizes clearer code at the cost of memory and processing speed at run time (though there are dedicated functional programming languages like Haskell that have built-in optimizations to help with this).</p>

<p>When we are finished, we could run some benchmark tests to compare the performance of these two approaches, but at a glance, my guess is that the FP version would be slower by a factor of up to 2X. As we run larger simulations with more iterations, this will really add up!</p>

<p>So let‚Äôs return to our checklist and finish implementing a full round of combat:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SIMULATE A ROUND OF COMBAT</span>
<span class="c1">// 1. Attacker rolls one die for each attacking unit,</span>
<span class="c1">//    **excluding any casualties**</span>
<span class="kd">let</span> <span class="nx">attackerHits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">attackerCasualties</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">attackerUnits</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">unit</span> <span class="o">=</span> <span class="nx">attackerUnits</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">roll</span> <span class="o">=</span> <span class="nx">rollD6</span><span class="p">();</span>

  <span class="c1">// 2. Attacker compares each die roll to the unit's attack stat</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">roll</span> <span class="o">&lt;=</span> <span class="nx">unit</span><span class="p">.</span><span class="nx">attack</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 3. Attacker records a hit for each die roll equal to or</span>
    <span class="c1">//    less than the unit's attack stat</span>
    <span class="nx">attackerHits</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 4. Defender rolls one die for each attacking unit</span>
<span class="c1">//    **excluding any casualties**</span>
<span class="kd">let</span> <span class="nx">defenderHits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">defenderCasualties</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">defenderUnits</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">unit</span> <span class="o">=</span> <span class="nx">defenderUnits</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
  <span class="kd">const</span> <span class="nx">roll</span> <span class="o">=</span> <span class="nx">rollD6</span><span class="p">();</span>

  <span class="c1">// 5. Defender compares each die roll to the unit's defense stat</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">roll</span> <span class="o">&lt;=</span> <span class="nx">unit</span><span class="p">.</span><span class="nx">defense</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 6. Defender records a hit for each die roll equal to or</span>
    <span class="c1">//    less than the unit's defense stat</span>
    <span class="nx">defenderHits</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 7. Attacker and defender remove units that were "hit"</span>
<span class="nx">attackerCasualties</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span>
  <span class="nx">attackerCasualties</span> <span class="o">+</span> <span class="nx">defenderHits</span><span class="p">,</span>
  <span class="nx">attackerUnits</span><span class="p">.</span><span class="nx">length</span>
<span class="p">);</span>
<span class="nx">defenderCasualties</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span>
  <span class="nx">defenderCasualties</span> <span class="o">+</span> <span class="nx">attackerHits</span><span class="p">,</span>
  <span class="nx">defenderUnits</span><span class="p">.</span><span class="nx">length</span>
<span class="p">);</span>
</code></pre></div></div>

<p>So now we‚Äôve added Steps 4-6, rolling for the defender and comparing the rolls to each unit‚Äôs <code class="language-plaintext highlighter-rouge">defense</code> stat. We‚Äôve also added a couple variables and logic for Step 7, which records the total number of casualties. We use <code class="language-plaintext highlighter-rouge">Math.min</code> to limit the number of casualties based on the number of attacking or defending units. We cannot take more casualties than we have units. We‚Äôve also updated the <code class="language-plaintext highlighter-rouge">for</code> loops to exclude casualties from rolling. As casualties go up, the <code class="language-plaintext highlighter-rouge">for</code> loop starts at a later index, so we end up rolling for fewer units.</p>

<p>From a gameplay perspective, deciding which units to remove first is very significant. In this case, the units at the beginning of each unit list are taken as ‚Äúcasualties‚Äù first and can no longer attack or defend once hit. So if stronger, more valuable units are listed first, they will be removed from combat first, and any competent A&amp;A player will tel you that, as a general rule, you want to remove your weakest, lowest-value units first.</p>

<p>For sake of simplicity, we can deal with this one of two ways: (1) we can ask the user to enter units in the order they expect them to be removed, or (2) we can automatically sort the list of units by their ipc value, like so.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">attackerUnits</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">ipc</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">ipc</span><span class="p">);</span>
<span class="nx">defenderUnits</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">ipc</span> <span class="o">-</span> <span class="nx">b</span><span class="p">.</span><span class="nx">ipc</span><span class="p">);</span>
</code></pre></div></div>

<p>In the real game, there are times where it makes strategic sense to sacrifice higher-valued units or allocate a hit to a Battleship, which has two hit points, but for the sake of simplicity, we will not address that here.</p>

<p>Now let‚Äôs look again at the alternative FP implementation of a combat round:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Steps 1-3: Attacker rolls and hit count, excluding casualties</span>
<span class="kd">const</span> <span class="nx">attackerHits</span> <span class="o">=</span> <span class="nx">attackerUnits</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">u</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">attackerCasualties</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">u</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">unit</span><span class="p">:</span> <span class="nx">u</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="nx">rollD6</span><span class="p">()</span> <span class="p">}))</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">roll</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">unit</span><span class="p">.</span><span class="nx">attack</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>

<span class="c1">// Steps 4-6: Defender rolls and hit count, excluding casualties</span>
<span class="kd">const</span> <span class="nx">defenderHits</span> <span class="o">=</span> <span class="nx">defenderUnits</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">u</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">defenderCasualties</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">u</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span> <span class="na">unit</span><span class="p">:</span> <span class="nx">u</span><span class="p">,</span> <span class="na">roll</span><span class="p">:</span> <span class="nx">rollD6</span><span class="p">()</span> <span class="p">}))</span>
  <span class="p">.</span><span class="nx">filter</span><span class="p">((</span><span class="nx">r</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">roll</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">unit</span><span class="p">.</span><span class="nx">defense</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span>

<span class="c1">// 7. Attacker and defender remove units that were "hit"</span>
<span class="nx">attackerCasualties</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span>
  <span class="nx">attackerCasualties</span> <span class="o">+</span> <span class="nx">defenderHits</span><span class="p">,</span>
  <span class="nx">attackerUnits</span><span class="p">.</span><span class="nx">length</span>
<span class="p">);</span>
<span class="nx">defenderCasualties</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span>
  <span class="nx">defenderCasualties</span> <span class="o">+</span> <span class="nx">attackerHits</span><span class="p">,</span>
  <span class="nx">defenderUnits</span><span class="p">.</span><span class="nx">length</span>
<span class="p">);</span>
</code></pre></div></div>

<p>It‚Äôs very similar. Here, we are recording casualties in the same way, and we‚Äôve added another <code class="language-plaintext highlighter-rouge">filter</code> call to the lists to remove casualties before rolling. Perhaps you are starting to see the ‚Äúfunctional‚Äù way of thinking, which is to send our unit lists through a ‚Äúpipeline‚Äù of chained functions until we reach the desired result. Again, this is much more concise than the <code class="language-plaintext highlighter-rouge">for</code>-loop, but may be less readable to beginners and will probably run slower.</p>

<p>And that‚Äôs it for simulating a combat round!</p>

<h2 id="coding-a-full-combat">Coding a Full Combat</h2>

<p>The individual rounds of combat are the real ‚Äúmeat‚Äù of this simulation. With that done, playing out a full combat is just a matter of looping until one side or the other has lost, checking after each iteration for a win, loss, or draw. Here‚Äôs what that looks like:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// STEPS IN A COMBAT</span>
<span class="c1">// 1. Set up the attacker and defender unit lists</span>
<span class="kd">const</span> <span class="nx">attackerList</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Infantry</span><span class="p">,</span> <span class="nx">Tank</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">defenderList</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Infantry</span><span class="p">];</span>

<span class="c1">// Also, reset casualties</span>
<span class="kd">const</span> <span class="nx">attackerCasualties</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">defenderCasualties</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">done</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 2. Do a round</span>
  <span class="c1">//    ... see above</span>

  <span class="c1">// 3. Check for win, loss, or draw</span>
  <span class="k">if</span> <span class="p">(</span>
    <span class="nx">attackerCasualties</span> <span class="o">===</span> <span class="nx">attackerList</span><span class="p">.</span><span class="nx">length</span> <span class="o">&amp;&amp;</span>
    <span class="nx">defenderCasualties</span> <span class="o">===</span> <span class="nx">defenderList</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">It's a draw!</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">done</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">attackerCasualties</span> <span class="o">===</span> <span class="nx">attackerList</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">Defender Wins!</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">done</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">defenderCasualties</span> <span class="o">===</span> <span class="nx">defenderList</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">Attacker Wins!</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">done</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And that‚Äôs all there is to this ‚Äúlayer‚Äù of things. We use the <code class="language-plaintext highlighter-rouge">while(!done)</code> loop to repeat rounds of combat until the number of casualties on either side or both sides equals the number of units. We use <code class="language-plaintext highlighter-rouge">alert</code> to display the result and set <code class="language-plaintext highlighter-rouge">done = true</code> to exit the loop.</p>

<p>Can you think of a better or more concise way to write the <code class="language-plaintext highlighter-rouge">if</code> statement that checks for the win condition? One alternative to complex <code class="language-plaintext highlighter-rouge">if...else if</code> statements is to decompose them into expressions and assign the result of those expressions to variables, like so:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// A side has lost when casualties equal their unit count</span>
<span class="nx">attackerLost</span> <span class="o">=</span> <span class="nx">attackerCasualties</span> <span class="o">===</span> <span class="nx">attackerList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="nx">defenderLost</span> <span class="o">=</span> <span class="nx">defenderCasualtie</span> <span class="o">===</span> <span class="nx">defenderList</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>

<span class="c1">// We're done if either side has lost</span>
<span class="nx">done</span> <span class="o">=</span> <span class="nx">attackerLost</span> <span class="o">||</span> <span class="nx">defenderLost</span><span class="p">;</span>

<span class="c1">// The attacker wins if they didn't lose and the defender did</span>
<span class="nx">attackerWon</span> <span class="o">=</span> <span class="o">!</span><span class="nx">attackerLost</span> <span class="o">&amp;&amp;</span> <span class="nx">defenderLost</span><span class="p">;</span>

<span class="c1">// The defender wins if they didn't lose and the attacker did</span>
<span class="nx">defenderWon</span> <span class="o">=</span> <span class="o">!</span><span class="nx">defenderLost</span> <span class="o">&amp;&amp;</span> <span class="nx">attackerLost</span><span class="p">;</span>

<span class="c1">// It's a draw if both sides lost</span>
<span class="nx">draw</span> <span class="o">=</span> <span class="nx">attackerLost</span> <span class="o">&amp;&amp;</span> <span class="nx">defenderLost</span><span class="p">;</span>
</code></pre></div></div>

<p>This approach looks a bit more verbose than the <code class="language-plaintext highlighter-rouge">if...else if</code> pattern, but it has the added benefit of being more explicit about what the comparison operators are intended to check. The logic is also cleanly separated between each value, which means that we can change how any one value is computed without affecting any of the other values. By contrast, <code class="language-plaintext highlighter-rouge">if...else if</code> chains can quickly become confusing, because each block depends on the logic of the previous block, so if you have a bug, you have to trace the whole chain to understand what‚Äôs going on.</p>

<p>One final benefit of this approach is that it separates our <em>data</em> and <em>logic</em> from the <em>presentation</em>. In the <code class="language-plaintext highlighter-rouge">if...else if</code> example, each block contained <code class="language-plaintext highlighter-rouge">alert()</code>s, which meant that the data (the value of <code class="language-plaintext highlighter-rouge">done</code>) and the logic (the <code class="language-plaintext highlighter-rouge">if...else if</code>) statements were all coupled together. By creating distinct values to represent the various outcomes, we can separately make a decision about how we want those results to be displayed to a user, whether via an <code class="language-plaintext highlighter-rouge">alert</code> or, as we‚Äôll see later, in the user interface.</p>

<h2 id="coding-the-monte-carlo-simulation">Coding the Monte Carlo Simulation</h2>

<p>Now that we can simulate complete multi-round combats, we‚Äôre ready to wrap everything up in a simulation of repeated combats. This step is going to be very much like the last.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// STEPS IN THE MONTE CARLO SIMULATION</span>
<span class="c1">// 1. Set up the attacker units, defender units, and `x` number of simulations to run</span>
<span class="kd">const</span> <span class="nx">attackerList</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Infantry</span><span class="p">,</span> <span class="nx">Tank</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">defenderList</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Infantry</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">simCount</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

<span class="c1">// We'll record wins/losses from the attacker's perspective</span>
<span class="kd">let</span> <span class="nx">wins</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">losses</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">draws</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">simCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 2. Run a combat</span>
  <span class="c1">// ... see above</span>

  <span class="c1">// 3. Record the combat result (win, loss, or draw)</span>
  <span class="nx">wins</span> <span class="o">+=</span> <span class="nx">attackerWon</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">losses</span> <span class="o">+=</span> <span class="nx">defenderWon</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="nx">draws</span> <span class="o">+=</span> <span class="nx">draw</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 4. Repeat from Step 2 until we have run `x` number of times</span>
<span class="p">}</span>

<span class="c1">// 5. Display results</span>
<span class="nx">alert</span><span class="p">(</span><span class="s2">`
wins: </span><span class="p">${</span><span class="nx">wins</span><span class="p">}</span><span class="s2">
losses: </span><span class="p">${</span><span class="nx">losses</span><span class="p">}</span><span class="s2">
draws: </span><span class="p">${</span><span class="nx">draws</span><span class="p">}</span><span class="s2">
success chance: </span><span class="p">${</span><span class="nx">wins</span> <span class="o">/</span> <span class="nx">simCount</span><span class="p">}</span><span class="s2">
`</span><span class="p">);</span>
</code></pre></div></div>

<p>So the main thing we‚Äôve done here is added variables to track the number of wins, losses, and draws from the attacker‚Äôs perspective. We check the win state after every combat and increment the appropriate counter. Here we have once again avoided <code class="language-plaintext highlighter-rouge">if...else if</code> statements by using ternary expressions (the <code class="language-plaintext highlighter-rouge">?...:</code> syntax) to check the values we declared in the previous section. So for example <code class="language-plaintext highlighter-rouge">wins += attackerWon ? 1 : 0</code> will add <code class="language-plaintext highlighter-rouge">1</code> to the win count if the attacker won, otherwise, it will add <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>We might have written the same logic using <code class="language-plaintext highlighter-rouge">if...else if</code></p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">attackerWon</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">wins</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">defenderWon</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">losses</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">draw</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">draw</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And that‚Äôs pretty clear. But again, the <code class="language-plaintext highlighter-rouge">if...else if</code> chain couples these lines together, whereas the ternary operator keeps each statement separate, rather than inter-dependent.</p>

<p>Finally, we display the aggregate results in an <code class="language-plaintext highlighter-rouge">alert()</code>. It gets the job done, but it‚Äôs rather ugly and inflexible, so next we‚Äôll look at how to wire this simulation up to a UI so that you can quickly run different scenarios.</p>

<h2 id="coding-an-interface">Coding an Interface</h2>

<p>At this point, we have a working simulation, but it‚Äôs not at all user friendly. In order to update the simulation scenario, you have to alter the code and refresh the page - that is, assuming you are running this JavaScript in an HTML file in a browser. Until now, we haven‚Äôt really talked about the runtime environment for this code.</p>

<p>Let‚Äôs use <a href="https://vuejs.org/">VueJS</a> to quickly prototype a UI. You can follow the <a href="https://vuejs.org/v2/guide/#Getting-Started">Getting Started</a> guide on the Vue website to create an HTML page that includes vuejs from a CDN or use an online prototyping tool like <a href="https://codepen.io">CodePen</a>.</p>

<p>First, we have to decide how we want to take input. The sky is the limit here, but let‚Äôs take a very simple approach. Let‚Äôs give the user three input boxes (1) a number input to specify the simulation count, (2) a text input for the list of attacker units, and (3) a text input for the list of defender units.</p>

<p>We‚Äôll allow users to supply a list of units using a string of characters like ‚ÄòI‚Äô for ‚ÄòInfantry‚Äô and ‚ÄòT‚Äô for ‚ÄòTank‚Äô. When they submit the form, we will parse these strings and create the actual <code class="language-plaintext highlighter-rouge">attackerList</code> and <code class="language-plaintext highlighter-rouge">defenderList</code>. Let‚Äôs start by setting up the template:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"app"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;h3&gt;</span>Axis <span class="err">&amp;</span> Allies Combat Simulator (Imperative Version)<span class="nt">&lt;/h3&gt;</span>

  <span class="nt">&lt;form</span> <span class="err">@</span><span class="na">submit.prevent=</span><span class="s">"run"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div&gt;</span>
      <span class="nt">&lt;label&gt;</span>Simulation Count<span class="nt">&lt;/label&gt;</span>
      <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"number"</span> <span class="na">v-model=</span><span class="s">"simCount"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;div&gt;</span>
      <span class="nt">&lt;label&gt;</span>Attacker Units<span class="nt">&lt;/label&gt;</span>
      <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">v-model=</span><span class="s">"attackerListStr"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;div&gt;</span>
      <span class="nt">&lt;label</span> <span class="na">for=</span><span class="s">"DefenderUnits"</span><span class="nt">&gt;</span>Defender Units<span class="nt">&lt;/label&gt;</span>
      <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">v-model=</span><span class="s">"defenderListStr"</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;button</span> <span class="na">type=</span><span class="s">"submit"</span><span class="nt">&gt;</span>Run Sim<span class="nt">&lt;/button&gt;</span>
  <span class="nt">&lt;/form&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>This mark-up creates a form with the three inputs we need. Note that we‚Äôve also included a <code class="language-plaintext highlighter-rouge">&lt;button&gt;</code> tag with <code class="language-plaintext highlighter-rouge">type="submit"</code> and attached a <code class="language-plaintext highlighter-rouge">@submit</code> event listener to the form. This allows the user to press the ‚ÄòEnter‚Äô key to submit the form or click on the submit button with their mouse. We‚Äôve also specified a <code class="language-plaintext highlighter-rouge">v-model</code> for each form input that corresponds to the three values we want to collect.</p>

<p>Next, we‚Äôll set up our VueJS code to power this template:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ... declare randBetween, rollD6, and Unit</span>

<span class="kd">const</span> <span class="nx">types</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">I</span><span class="p">:</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="dl">"</span><span class="s2">Infantry</span><span class="dl">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
  <span class="na">T</span><span class="p">:</span> <span class="k">new</span> <span class="nx">Unit</span><span class="p">(</span><span class="dl">"</span><span class="s2">Tank</span><span class="dl">"</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">app</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">({</span>
  <span class="na">el</span><span class="p">:</span> <span class="dl">"</span><span class="s2">#app</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">simCount</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
      <span class="na">attackerListStr</span><span class="p">:</span> <span class="dl">"</span><span class="s2">IT</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">defenderListStr</span><span class="p">:</span> <span class="dl">"</span><span class="s2">I</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">results</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
    <span class="p">};</span>
  <span class="p">},</span>
  <span class="na">methods</span><span class="p">:</span> <span class="p">{</span>
    <span class="nx">buildUnitList</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">unit</span> <span class="o">=</span> <span class="nx">types</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">unit</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">unit</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="nx">run</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">results</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
      <span class="kd">const</span> <span class="nx">attackerList</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">buildUnitList</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">attackerListStr</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">defenderList</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">buildUnitList</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">defenderListStr</span><span class="p">);</span>

      <span class="c1">// Run the simulation the number of times indicated by</span>
      <span class="c1">// `simCount` and keep track of attacker and defender wins.</span>
      <span class="kd">const</span> <span class="nx">timeStart</span> <span class="o">=</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
      <span class="kd">let</span> <span class="nx">attackerWins</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">defenderWins</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kd">let</span> <span class="nx">draws</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">simCount</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... RUN COMBAT (see above)</span>

        <span class="c1">// Summarize stats across all simulated combats</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">results</span> <span class="o">=</span> <span class="p">{</span>
          <span class="nx">attackerWins</span><span class="p">,</span>
          <span class="nx">defenderWins</span><span class="p">,</span>
          <span class="nx">draws</span><span class="p">,</span>
          <span class="na">successChance</span><span class="p">:</span> <span class="nx">attackerWins</span> <span class="o">/</span> <span class="k">this</span><span class="p">.</span><span class="nx">simCount</span><span class="p">,</span>
          <span class="na">simCount</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">simCount</span><span class="p">,</span>
          <span class="na">simDuration</span><span class="p">:</span> <span class="nb">String</span><span class="p">(</span><span class="nb">Date</span><span class="p">.</span><span class="nx">now</span><span class="p">()</span> <span class="o">-</span> <span class="nx">timeStart</span><span class="p">)</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">ms</span><span class="dl">"</span><span class="p">,</span>
        <span class="p">};</span>
      <span class="p">}</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">});</span>
</code></pre></div></div>

<p><a href="https://codepen.io/whusterj/pen/b4397c0d26fc315dae283d682f7819d8">View the Complete Code on CodePen</a></p>

<p>A lot of this code should look familiar, though there are a few changes and new additions. Notably, we‚Äôve added a <code class="language-plaintext highlighter-rouge">types</code> object that maps the letters ‚ÄòI‚Äô and ‚ÄòT‚Äô to the Infantry and Tank object instances. This pattern is often called a ‚Äúlookup table‚Äù or ‚Äúdictionary,‚Äù and it is a convenient way to avoid using <code class="language-plaintext highlighter-rouge">switch</code> statements or repetitive <code class="language-plaintext highlighter-rouge">if...else if</code> statements to look up one value based on another value.</p>

<p>Here, the <code class="language-plaintext highlighter-rouge">types</code> lookup table is used in the <code class="language-plaintext highlighter-rouge">buildUnitList</code> method, which loops over each character in the string and builds a new list of unit object references. Unrecognized characters are ignored.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Examples of strings converted to unit lists</span>

<span class="kd">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">IT</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">unitList</span> <span class="o">=</span> <span class="nx">buildUnitList</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>
<span class="c1">// unitList = [Infantry, Tank]</span>

<span class="kd">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">IIITTT</span><span class="dl">"</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">unitList</span> <span class="o">=</span> <span class="nx">buildUnitList</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>
<span class="c1">// unitList = [Infantry, Infantry, Infantry, Tank, Tank]</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">run()</code> method is where the magic happens, and all of our simulation code has been placed there. The first thing the <code class="language-plaintext highlighter-rouge">run()</code> method does is parse the user input using <code class="language-plaintext highlighter-rouge">buildUnitList</code>. We‚Äôve also added the variable <code class="language-plaintext highlighter-rouge">timeStart</code> that grabs a date object before running the simulation. This allows us to compute how long, in milliseconds, it takes for our simulation to run.</p>

<p>The rest of the code is very much the same until the simulation completes. At that point, the results are put together into a <code class="language-plaintext highlighter-rouge">results</code> object, instead of being displayed in an <code class="language-plaintext highlighter-rouge">alert()</code>. Again, this demonstrates the principle of decoupling our data and logic from how it‚Äôs presented.</p>

<p>Because VueJS is reactive, we can present the data rather easily by updating the template:</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">"app"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;form&gt;</span><span class="c">&lt;!-- ... see above --&gt;</span><span class="nt">&lt;/form&gt;</span>

  <span class="nt">&lt;div</span> <span class="na">v-if=</span><span class="s">"results !== null"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h3&gt;</span>Sim Results<span class="nt">&lt;/h3&gt;</span>
    <span class="nt">&lt;p&gt;</span>
      <span class="nt">&lt;strong&gt;</span>Sim Duration:<span class="nt">&lt;/strong&gt;</span> <span class="nt">&lt;br</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;strong&gt;</span>Attacker Wins:<span class="nt">&lt;/strong&gt;</span> <span class="nt">&lt;br</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;strong&gt;</span>Defender Wins:<span class="nt">&lt;/strong&gt;</span> <span class="nt">&lt;br</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;strong&gt;</span>Draws:<span class="nt">&lt;/strong&gt;</span> <span class="nt">&lt;br</span> <span class="nt">/&gt;</span>
      <span class="nt">&lt;strong&gt;</span>Success Chance:<span class="nt">&lt;/strong&gt;</span> 
    <span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>The results <code class="language-plaintext highlighter-rouge">div</code> will only appear when <code class="language-plaintext highlighter-rouge">results !== null</code>, and <code class="language-plaintext highlighter-rouge">results</code> is <code class="language-plaintext highlighter-rouge">null</code> by default, so this div will be hidden until the simulation has finished running for the first time. The rest of the template lists the results in a <code class="language-plaintext highlighter-rouge">&lt;p&gt;</code> tag.</p>

<p>And with that, we have successfully hooked our simulation up to a basic UI that allows us to explore different <em>Axis &amp; Allies</em> combat scenarios. <a href="https://codepen.io/whusterj/pen/b4397c0d26fc315dae283d682f7819d8">You can check out the complete code and interact with it on CodePen</a></p>

<h2 id="summary">Summary</h2>

<p>In this article we explored a variety of topics, from the motivating problem of combat outcome probabilities in <em>Axis &amp; Allies</em> to code-level considerations, such as the merits of using <code class="language-plaintext highlighter-rouge">if...else if</code> statements. Perhaps the most interesting thing to me going through this exercise was the realization that the most ‚Äúnaive‚Äù and straightforward implementation would be best not only for performance, but also for readability for novice devs unfamiliar with functional programming practices.</p>

<p>This is the main reason I was motivated to write this blog post. I realize I have been conditioned to frown upon <code class="language-plaintext highlighter-rouge">for</code> loops in code, having ‚Äúevolved‚Äù my personal practice to prefer <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code>, and friends. In my first attempt implementing this simulator, I used those functions along with other FP concepts like immutability. This meant there were many unncessary extra loops and lots of extra memory consumption as I generated several new objects per loop. The simulation was very slow. I tried to run a simulation with multiple units and 1,000,000 iterations, and my browser locked up. Chrome slowly began consuming more and more system memory. It peaked at 14% before I force-quit the browser. I knew JavaScript was slow, but ‚Ä¶wow.</p>

<p>After that, I decided to go all-out on performance and re-implement the simulator in C as a command-line application, just to see how much faster this could be. Plain C does not have these FP methods, so it was back to <code class="language-plaintext highlighter-rouge">for</code> loops. C also forces you to think more about memory, so that‚Äôs when I hit on the idea of having the units be static objects in memory (<code class="language-plaintext highlighter-rouge">struct</code>s in C) and the unit lists be lists of <em>references</em> (or ‚Äúpointers‚Äù) to those values. All other values in the program would be integers that I would increment, so I knew the memory footprint would be small. The C program can run millions of trials with multiple units in under 10 seconds. Then I went back to JavaScript and applied the same principles. The JS version is still much slower, but it can run millions of trials now. Furthermore, the final JS and C implementations are practically identical in terms of syntax, save for C‚Äôs type annotations. It‚Äôs pretty fascinating.</p>

<p>It‚Äôs a lesson that is always useful to learn again no matter how long you do this: that fancy, advanced, and ‚Äúmodern‚Äù approaches to programming are not essential to writing effective software.</p>

<p>You can reach me at whusterj@gmail.com. Please feel free to reach out with questions, comments, or corrections regarding this content. I look forward to hearing from you!</p>

<hr />

<p><em>Notes</em></p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Andrew Howlett demonstrates a ‚Äúbrute force‚Äù method and takes this obsession to a whole new level in his paper <a href="https://www.radagast.ca/axis_and_allies/probability_of_outcomes_of_a&amp;a_battles.pdf">Probability of Outcomes of A&amp;A Battles</a>. He also wrote his own <a href="https://radagast.ca/axis_and_allies/batsimv2.html">very robust desktop A&amp;A combat simulator back in 2003</a> that also uses a Monte Carlo method.¬†<a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET