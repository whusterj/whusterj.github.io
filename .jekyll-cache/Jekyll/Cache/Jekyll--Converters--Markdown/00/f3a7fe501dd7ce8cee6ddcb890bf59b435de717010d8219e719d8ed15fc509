I" X<p><a href="https://github.com/whusterj/wtf">Source Code on Github</a></p>

<p>Most programmers are familiar with this iconic comic:</p>

<p><img src="/static/images/posts/wtfm.jpg" alt="WTF" />
<a href="http://www.osnews.com/story/19266/WTFs_m">Source</a></p>

<p>And anyone who has ever done code review or even just tried to read code knows how true this is.</p>

<p>Well, I‚Äôve been doing more code reviews lately, and I found myself wishing I had an easy way to record all those moments that just make me go: ‚ÄúWTF‚Äù.</p>

<p>Seriously, though, it‚Äôs useful to keep a log of your thoughts while doing code review for later summary, and I thought it could be even better to timestamp those thoughts. That way, I could quantify exactly how much of my life had been wasted on crappy code. Inspired by the comic above, I also wanted to generate a WTF/min score as a useful (stretching that word) code review benchmark.</p>

<p>It‚Äôs also just plain cathartic to pound out a WTF or two if ever you find yourself looking at very. bad. code.</p>

<h2 id="the-basics">The Basics</h2>

<p>The core of wtf.py is very simple: when executed, the script appends a new line to a text file containing an ISO-formatted timestamp and optional message. Read the code comments to understand what‚Äôs going on.</p>

<p>Let‚Äôs start by writing a minimum-viable version of wtf.py:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
# ^ Make sure this is the first line of the file. This instructs your
# shell to use Python to execute this file. In Linux, first make the file
# executable with the command:
#
#    chmod +x wtf.py
#
# and then you will be able to run the script like so:
#
#    ./wtf.py
#
# Of course, you can also always run the script with python directly:
#
#    python wtf.py
#
</span>
<span class="s">"""wtf.py Minimum Viable"""</span>

<span class="c1"># We'll need the datetime module to create timestamps
</span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>


<span class="c1"># The `write_wtf` function:
# Putting logic inside a function is always a good idea. This will
# allow other developers to import the module and use this function.
</span><span class="k">def</span> <span class="nf">write_wtf</span><span class="p">():</span>
    <span class="c1"># By default, wtf.py writes to a file (let's call it a "WTF Log File")
</span>    <span class="c1"># called 'wtfs.txt' in the current directory.
</span>    <span class="n">outfile</span> <span class="o">=</span> <span class="s">'wtfs.txt'</span>

    <span class="c1"># Next, we open the output file in append-only mode using 'a' as
</span>    <span class="c1"># the second parameter. The '+' sign tells Python to create a new file,
</span>    <span class="c1"># if it doesn't already exist.
</span>    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="s">'a+'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># Get the current timestamp
</span>        <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">()</span>

        <span class="c1"># Write the timestamp to the file in ISO Format and create
</span>        <span class="c1"># a line break with '\r\n'.
</span>        <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">isoformat</span><span class="p">())</span>
        <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">'</span><span class="se">\r\n</span><span class="s">'</span><span class="p">)</span>


<span class="c1"># `if __name__ == "__main__"` code block:
# Code that should only be run from the command line should go inside
# this block. That way, it will not be unintentionally executed if
# the module is imported by another Python program.
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">write_wtf</span><span class="p">()</span>
</code></pre></div></div>

<p>And that‚Äôs all we need to get started recording WTF moments. Now just run <code class="language-plaintext highlighter-rouge">python wtf.py</code>. It immediately executes the <code class="language-plaintext highlighter-rouge">write_wtf()</code> function. When you look at <code class="language-plaintext highlighter-rouge">wtfs.txt</code>, you will be able to see the exact moments that caused you to flip your lid ‚Äî with microsecond precision.</p>

<p><em>Quick note on the timestamps:</em> The ISO timestamps generated by this script will be in local time and ‚Äònaive‚Äô, meaning they will not record any timezone. This is in the interest of simplicity and to avoid introducing code dependencies like python dateutil, which is better at parsing datetimes with timezones. When parsing WTF Log Files, wtf.py will assume that timestamps in the same log file have the same timezone‚Ä¶ This kind of assumption is usually not safe, but, hey. We‚Äôre just having fun here.</p>

<h2 id="adding-messages">Adding Messages</h2>

<p>That‚Äôs all well and good, but suppose you also want to record the cause of your fury?</p>

<p>This is a good opportunity to use Python‚Äôs built-in <code class="language-plaintext highlighter-rouge">argparse</code> library to practice defining argument options and parsing command-line arguments. That may seem intimidating, but it‚Äôs actually quite easy to use!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># ... Code ommitted
</span>
<span class="c1"># We'll need argparse
</span><span class="kn">import</span> <span class="nn">argparse</span>

<span class="c1"># Here we set up the argument parser class and define the optional
# '--message' option. In typical command line style, the description
# and help text can be displayed with the '-h' option:
#
#     python wtf.py -h
#
</span><span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s">"Easily record WTF moments."</span><span class="p">)</span>
<span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span>
    <span class="c1"># Options prefixed with a double-dash will not be required.
</span>    <span class="c1"># You can also provide a short version of the option. Here
</span>    <span class="c1"># I've added '-m', short for '--message'.
</span>    <span class="s">'-m'</span><span class="p">,</span> <span class="s">'--message'</span><span class="p">,</span>
    <span class="c1"># Require that the value of message is a string
</span>    <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
    <span class="n">help</span><span class="o">=</span><span class="s">'Record the thing that made you go WTF'</span>
<span class="p">)</span>


<span class="c1"># Notice the new 'message' parameter of the write_wtf function.
# Since it's optional, the default value will be None.
</span><span class="k">def</span> <span class="nf">write_wtf</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">outfile</span> <span class="o">=</span> <span class="s">'wtfs.txt'</span>

    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outfile</span><span class="p">,</span> <span class="s">'a+'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">()</span>
        <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">now</span><span class="p">.</span><span class="n">isoformat</span><span class="p">())</span>

        <span class="c1"># And here's the only other change -- if `message` has a value,
</span>        <span class="c1"># then add a space and the message to the current line.
</span>        <span class="k">if</span> <span class="n">message</span><span class="p">:</span>
            <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">' '</span> <span class="o">+</span> <span class="n">message</span><span class="p">)</span>
        <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="s">'</span><span class="se">\r\n</span><span class="s">'</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="c1"># Now we'll parse the command line arguments before writing
</span>    <span class="c1"># down the WTF moment. `args.message` will have a value whenever
</span>    <span class="c1"># the user provides the --message or -m option on the command line.
</span>    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">message</span>

    <span class="n">write_wtf</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</code></pre></div></div>

<p>Use your message option like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python wtf.py -m "Use SPACES not TABS!!!"
</code></pre></div></div>

<p>So now you can record both the exact moment you WTF‚Äôd and <em>why</em>. Amazing.</p>

<h2 id="parsing-wtf-logs">Parsing WTF Logs</h2>

<p>Once we‚Äôve recorded a few WTFs, we can use <code class="language-plaintext highlighter-rouge">cat wtfs.txt</code> or open our WTF Log File in a text editor at any time to review the contents. For example, I‚Äôd do this once I‚Äôve finished my code review and need to summarize all of the unspeakable horrors I uncovered.</p>

<p>But the REAL beauty of the structured text file generated by wtf.py is that we can PARSE it and run some numbers! This is how we get to that holy grail benchmark number from the famous comic: <em>WTFs per minute</em>.</p>

<p>A typical WTF Log File will look like this</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2018-05-05T13:55:02.328431
2018-05-05T13:56:08.034393 WHYYyyyy
2018-05-05T14:02:14.222576 I can't even...
</code></pre></div></div>

<p>etc‚Ä¶ So the first ‚Äòword‚Äô of each line will be the ISO timestamp written down by the <code class="language-plaintext highlighter-rouge">write_wtf()</code> function. To calculate WTFs/minute, we just need to parse those timestamps into Python datetime objects, subtract the last timestamp from the first to get the total duration in minutes and then divide the total number of WTFs by the total minutes. Easy peasy. Let‚Äôs code it up.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1"># ... Code skipped
</span>
<span class="c1"># Add an argument to the argument parser for reading WTF log files.
# Its value should be the name of the file to read.
</span><span class="n">parser</span><span class="p">.</span><span class="n">add_argument</span><span class="p">(</span>
    <span class="s">'-r'</span><span class="p">,</span> <span class="s">'--read'</span><span class="p">,</span>
    <span class="n">help</span><span class="o">=</span><span class="s">'Read a WTF log file. Outputs stats and WTFs per minute.'</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">_parse_timestamp</span><span class="p">(</span><span class="n">timestamp</span><span class="p">):</span>
    <span class="s">"""Get a timezone-naive datetime object from an ISO timestamp string.

    This is a helper function for consistently parsing the timestamps in
    WTF log files. The undescore in front of the function is a common
    programming convention that indicates that this function is 'private'
    and should only be used by this module.

    In fact, if you import this module into another module using

        from wtf import *

    This function will be ignored by the import. Defining functions like
    this is in Python is nothing more than a matter of style preference,
    since no code is truly private or protected. You can think of it as
    a message to other developers, saying, "You probably shouldn't use
    this function, unless you really know what you're doing."

    Args:
        timestamp (str): Timezone-naive ISO-formatted datetime string.
    """</span>
    <span class="n">ISO_FMT</span> <span class="o">=</span> <span class="s">'%Y-%m-%dT%H:%M:%S.%f'</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="p">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">timestamp</span><span class="p">,</span> <span class="n">ISO_FMT</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_stats</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="s">"""Read a WTFs log file and compute statistics, including:
         - Total WTFs
         - Total Duration
         - WTFs/minute

    Args:
        filename (str): Path to the WTF log file.

    Returns:
        dict: Dictionary of statistics, including:
    """</span>
    <span class="n">conent</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Open the file for reading and get all of the lines as a list
</span>    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">content</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">readlines</span><span class="p">()</span>

    <span class="c1"># Strip the line endings and whitespace from each line
</span>    <span class="n">content</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">content</span><span class="p">]</span>

    <span class="c1"># Grab just the timestamps from each line. After splitting on
</span>    <span class="c1"># spaces, this should always be the first element in the list.
</span>    <span class="c1"># ... If this were a serious utility, we might add some error
</span>    <span class="c1"># handling in here to detect malformed WTF log files and show
</span>    <span class="c1"># a friendly error message.
</span>    <span class="n">timestamps</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">' '</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">content</span><span class="p">]</span>

    <span class="c1"># Calculate the duration from the first WTF moment to the last.
</span>    <span class="n">start</span> <span class="o">=</span> <span class="n">_parse_timestamp</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="o">*</span><span class="n">timestamps</span><span class="p">))</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">_parse_timestamp</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="o">*</span><span class="n">timestamps</span><span class="p">))</span>
    <span class="n">time_diff</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span>
    <span class="n">total_minutes</span> <span class="o">=</span> <span class="n">time_diff</span><span class="p">.</span><span class="n">seconds</span> <span class="o">/</span> <span class="mi">60</span>

    <span class="c1"># Prevent division by zero for timestamps that are very close.
</span>    <span class="c1"># (this is a bit of a hack)
</span>    <span class="k">if</span> <span class="n">total_minutes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">total_minutes</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Return a dictionary of key metrics!
</span>    <span class="k">return</span> <span class="p">{</span>
        <span class="s">'total'</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">timestamps</span><span class="p">),</span>
        <span class="s">'duration'</span><span class="p">:</span> <span class="n">total_minutes</span><span class="p">,</span>
        <span class="s">'wtfs_per_min'</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">timestamps</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_minutes</span><span class="p">,</span>
    <span class="p">}</span>


<span class="c1"># ... Code skipped
</span>
<span class="c1"># Now we're also getting the value for args.read. If that option is used,
# then the script invokes the get_stats() function on the provided filename.
# Otherwise, it writes a new WTF moment, just like before.
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">message</span>
    <span class="n">readfile</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">read</span>

    <span class="k">if</span> <span class="n">readfile</span><span class="p">:</span>
        <span class="c1"># The --read option should not be combined with the
</span>        <span class="c1"># --message option. If the user tries this, raise a
</span>        <span class="c1"># ValueError and show a nice message.
</span>        <span class="k">if</span> <span class="n">message</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span>
                <span class="s">'The --read option cannot be used with '</span>
                <span class="s">'the --message option.'</span>
            <span class="p">)</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="n">get_stats</span><span class="p">(</span><span class="n">readfile</span><span class="p">)</span>
        <span class="c1"># Print out those stats!
</span>        <span class="k">print</span><span class="p">(</span><span class="s">'Total WTFs:'</span><span class="p">,</span> <span class="n">stats</span><span class="p">[</span><span class="s">'total'</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Duration (minutes):'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s">'duration'</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'WTFs/min:'</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s">'wtfs_per_min'</span><span class="p">],</span> <span class="mi">3</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">write_wtf</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>
</code></pre></div></div>

<p>Beautiful. Now let‚Äôs use our new option to see how the latest code review went:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python wtf.py <span class="nt">-r</span> wtfs.txt
Total WTFs: 35
Duration <span class="o">(</span>minutes<span class="o">)</span>: 20.54
WTFs/min: 1.704
</code></pre></div></div>

<p>More than one WTF per minute? Oh, boy‚Ä¶ That‚Äôs a pretty bad score. I might have never known without this script. Thanks, wtf.py!</p>

<h2 id="next-steps">Next Steps</h2>

<p>Yes, this is a pretty exhaustive explanation of a fairly simple tool, but I hope it helps a few beginners understand the power of the command line and a simple text file. This is easy to forget in a world of web apps, frameworks, database servers, containerization, etc, etc. By staying focused on just the basics, you can whip up something useful to you in a matter of minutes.</p>

<p>And what more could be done with this? Here are a couple ideas:</p>

<ul>
  <li>Add an option for specifying the name of the output file (instead of just wtfs.txt)</li>
  <li>Integrate this with a text editor like sublime text to record comments against actual lines of code.</li>
  <li>Turn this into a social web or mobile app. What if people could share their WTF moments throughout the day with some richer media: geolocation, images, video, etc.?</li>
</ul>
:ET